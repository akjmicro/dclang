# definition of 2pi
pi 2 * const 2PI

# definition of 2 / pi
pi 2 / const PI_DIV_2

# sample rate and bit depth here
# can be 8000e, 44100e, etc. etc
48000 const SAMPLE_RATE

# more efficient, for multiplication
1 SAMPLE_RATE / const INV_SAMPLE_RATE

# useful in normalized frequency calculations:
2PI SAMPLE_RATE / const 2PIDSR

# 32-bit audio sample depth
0x7fffffff const BIT_DEPTH

# setup timestamp; unit will be samples.
var SAMPLE_CLOCK
0 SAMPLE_CLOCK !

# setup channels
var LCHAN
var RCHAN

# We need to create a common, general space for phasor accumulators.
# that happens here:
var _PHASOR_COUNT
var _PHASOR_ARRAY 64 allot

: _reset_phasor_count  0 _PHASOR_COUNT ! ;

: _advance_phasor_count _PHASOR_COUNT @ 1 + _PHASOR_COUNT ! ;

: seconds2samples SAMPLE_RATE * round ;

# sample clock (timestamp) and channel routines here
: t SAMPLE_CLOCK @ ;
: lcget LCHAN @ ;
: lcset LCHAN ! ;
: rcget RCHAN @ ;
: rcset RCHAN ! ;
: _clear_channels  0.0 lcset 0.0 rcset ;

: t+
  # advance the clock
  1 SAMPLE_CLOCK @ + SAMPLE_CLOCK !
  _clear_channels
  _reset_phasor_count
;

: freq2sample_phase INV_SAMPLE_RATE * ;

: phasor-pointer
  _PHASOR_ARRAY _PHASOR_COUNT @ +
;

: phasor
  # get current phase; wrap around 0-1:
  freq2sample_phase
  # grab the accumulator value:
  phasor-pointer @
  # add, wrap-around from 0.0-1.0
  + 1.0 %
  # write back current value:
  dup phasor-pointer !
  # update count reference (this will be reset by the clock advance) :
  _advance_phasor_count
;

# a simple metronome trigger:
# ( freq -- sig )
: metro phasor 0.001 <= ;

# a gate signal:
# ( width freq -- sig )
: gate phasor > ;

# phase --> sine
: sine phasor 2PI * sin ;

# FM osc; basic carrier/modulator pair
: fm
  # ( carrier_freq mod_ratio index -- sig )
  swap 2 pick * sine *
  swap phasor + 1.0 %
  2PI * sin
;

###############
# delay stuff #
###############

SAMPLE_RATE 8 * const 8SEC_STORAGE_SIZE
2 const DELAY_HEADER_SIZE
DELAY_HEADER_SIZE 8SEC_STORAGE_SIZE + const DELAY_STRUCT_SIZE

: create-delay-line var DELAY_STRUCT_SIZE allot ;

: init-delay-line
  # ( delay-struct -- )
  8SEC_STORAGE_SIZE over !
  0 over 1 + !
  8SEC_STORAGE_SIZE times
    0.0 over i + DELAY_HEADER_SIZE + !
  again
  drop
;

: %abs 2dup % over + swap % swap drop ;

: _get-delay-position      1 + @ ;
: _set-delay-position      1 + ! ;
: _set-delay-value         dup _get-delay-position DELAY_HEADER_SIZE + + ! ;
: _read-delay-pos-wrapped  over @ %abs DELAY_HEADER_SIZE + + @ ;

: _get-floor-val
  2dup floor _read-delay-pos-wrapped
;

: _get-ceil-val
  2 pick 2 pick ceil _read-delay-pos-wrapped
;

: _interpolate
  # ( real-val floor-val ceil-val -- interpolated_val )
  over - rot 1.0 % * +
;

: delay-read
  # ( delay-struct time -- delsig )
  # convert time offset to samples:
  SAMPLE_RATE *
  # add distance from write offset:
  over _get-delay-position swap -
  _get-floor-val _get-ceil-val _interpolate
  swap drop
;

: delay-write
  # ( sig delay-struct -- )
  # put it into the current write position
  tuck _set-delay-value
  # increment the write position
  t over @ % swap _set-delay-position
;

########
# port #
########

# A portamento can be roughly done by grabbing and saving a previous sample,
# considering that a starting point for the next sample 'target', and making
# the decision: is this a rising slope or a falling slope? We have half-way
# point parameters for both. The algorithm is basically:
#   * fetch the previous sample value (call it the 'oldsig')
#   * fetch the current signal (call it the 'sig')
#   * if the previous sample is lower than the current signal, add:
#       sig oldsig - 0.5 * rise-time-in-samples /
#       and +/save it to the accumulator
#   * if the previous sample is higher than the current signal, add:
#       sig oldsig - 0.5 * fall-time-in-samples /
#       ...and +/save it to the accumulator
# Neat bonus: this 'port' ugen can be used to make envelopes!
# See the example file 'bell_of_doom.fs' for an example.

: _port-factor 1 swap 0.5 * SAMPLE_RATE * / ;
: _get-rising-factor 1 + @ ;
: _get-falling-factor 2 + @ ;

: create-port-struct
  # ( rise-sec fall-sec -- struct )
  create swap
  0.0 , _port-factor , _port-factor ,
;

: port
  # ( sig pa -- out-sig )
  tuck @ - dup
  0 >
  if
    2dup swap _get-rising-factor *
  else
    2dup swap _get-falling-factor *
  endif
  swap drop over @ + tuck swap !
;

##########################
# filters (non-resonant) #
##########################
# Implementation of 1st-order allpass, and derived low- and highpass
# filters as side-effects. These are filters w/o Q (resonant peaks).

: xt1-allpass 0 + ;
: yt1-allpass 1 + ;
: xt2-allpass 2 + ;
: yt2-allpass 3 + ;
: prvcf-allpass 4 + ;
: c-param-allpass 5 + ;

: make-allpass-struct create 6 allot ;
: make-lowpass-struct make-allpass-struct ;
: make-highpass-struct make-allpass-struct ;

: reinit-allpass
  # ( struct -- )
  0 over xt1-allpass !
  0 over yt1-allpass !
  0 over xt2-allpass !      # unused in 1st order
  0 over yt2-allpass !      # unused in 1st order
  0 over prvcf-allpass !
  0 over c-param-allpass !
;

: _get-c-factor freq2sample_phase pi * tan ;

: calc-c
  # ( freq -- coeff )
  _get-c-factor
  dup 1 - swap 1 + /
;

: allpass1
  # ( sig cf struct reinit -- output-sig )
  {reinit} if
    {struct} reinit-allpass
  endif
  # if cutoff frequency has changed:
  {struct} prvcf-allpass @ cf <> if
    cf calc-c {struct} c-param-allpass !
  endif
  {struct} c-param-allpass @ { F: c-factor }
  c-factor sig *
  {struct} xt1-allpass @ +
  c-factor {struct} yt1-allpass @ * - { F: y }
  # UPDATE:
  {cf} {struct} prvcf-allpass f!
  y {struct} yt1-allpass f!
  sig {struct} xt1-allpass f!
  y ;

: lowpass1
  # ( sig cf struct reinit -- output-sig )
  {reinit} if
    {struct} reinit-allpass
  endif
  {sig} {sig} {struct} {reinit} {cf} allpass1 + 0.5 *
;

: highpass1
  # ( sig cf struct reinit -- output-sig )
  reinit if
    struct reinit-allpass
  endif
  sig sig struct reinit cf allpass1 - 0.5 * ;

##########
# OUTPUT #
##########

# will send out to global L and R channels 
# ( sig pan -- )
: panmix
  2dup
  PI_DIV_2 * sin
  * lcget + lcset
  PI_DIV_2 * cos
  * rcget + rcset
;

# sending out the signal
: sendout
  BIT_DEPTH * round bytes32
;

: stereo-out
  lcget sendout
  rcget sendout
;
