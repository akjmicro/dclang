###############
# DCLANG DSP! #
###############

# definition of 2pi
pi 2 * const 2PI

# definition of 2 / pi
pi 2 / const PI_DIV_2

# sample rate and bit depth here
# can be 8000e, 44100e, etc. etc
48000 const SAMPLE_RATE

# more efficient, for multiplication
1 SAMPLE_RATE / const INV_SAMPLE_RATE

# useful in normalized frequency calculations:
2PI SAMPLE_RATE / const 2PIDSR

# 32-bit audio sample depth
0x7fffffff const BIT_DEPTH

# setup timestamp; unit will be samples.
var SAMPLE_CLOCK
0 SAMPLE_CLOCK !

# setup channels
var LCHAN
var RCHAN

# We need to create a common, general space for phasor accumulators.
# that happens here:
var _PHASOR_COUNT
var _PHASOR_ARRAY 64 allot

: _reset_phasor_count  0 _PHASOR_COUNT ! ;

: _advance_phasor_count _PHASOR_COUNT @ 1 + _PHASOR_COUNT ! ;

: seconds2samples SAMPLE_RATE * round ;

# sample clock (timestamp) and channel routines here
: t SAMPLE_CLOCK @ ;
: lcget LCHAN @ ;
: lcset LCHAN ! ;
: rcget RCHAN @ ;
: rcset RCHAN ! ;
: _clear_channels  0.0 lcset 0.0 rcset ;

: t+
  # advance the clock
  1 SAMPLE_CLOCK @ + SAMPLE_CLOCK !
  _clear_channels
  _reset_phasor_count
;

: freq2sample_phase INV_SAMPLE_RATE * ;

: phasor-pointer
  _PHASOR_ARRAY _PHASOR_COUNT @ +
;

###############
# OSCILLATORS #
###############

: phasor
  # get current phase; wrap around 0-1:
  freq2sample_phase
  # grab the accumulator value:
  phasor-pointer @
  # add, wrap-around from 0.0-1.0
  + 1.0 %
  # write back current value:
  dup phasor-pointer !
  # update count reference (this will be reset by the clock advance) :
  _advance_phasor_count
;

# a simple metronome trigger:
# ( freq -- sig )
: metro phasor 0.001 <= ;

# a gate signal:
# ( width freq -- sig )
: gate phasor > ;

# phase --> sine
: sine phasor 2PI * sin ;

# FM osc; basic carrier/modulator pair
: fm
  # ( carrier_freq mod_ratio index -- sig )
  swap 2 pick * sine *
  swap phasor + 1.0 %
  2PI * sin
;

#########
# NOISE #
#########

var div_by 0xffffffff 1 >> div_by !

var last_num clock 0xffffffff and last_num !

: bit32mask 0xffffffff and ;

: xorshift-rand
  last_num @
  dup 13 << bit32mask xor
  dup 17 >> bit32mask xor
  dup  5 << bit32mask xor
  dup last_num !
;

: noise
  # ( -- sig )
  xorshift-rand div_by / 1.0 % 2 * 1.0 -
;

: randint
  # ( range -- int )
  noise abs * floor
;


#########
# DELAY #
#########

SAMPLE_RATE 8 * const 8SEC_STORAGE_SIZE
2 const DELAY_HEADER_SIZE
DELAY_HEADER_SIZE 8SEC_STORAGE_SIZE + const DELAY_STRUCT_SIZE

: make-delay-line var DELAY_STRUCT_SIZE allot ;

: init-delay-line
  # ( delay-struct -- )
  8SEC_STORAGE_SIZE over !
  0 over 1 + !
  8SEC_STORAGE_SIZE times
    0.0 over i + DELAY_HEADER_SIZE + !
  again
  drop
;

: %abs 2dup % over + swap % swap drop ;

: _get-delay-position      1 + @ ;
: _set-delay-position      1 + ! ;
: _set-delay-value         dup _get-delay-position DELAY_HEADER_SIZE + + ! ;
: _read-delay-pos-wrapped  over @ %abs DELAY_HEADER_SIZE + + @ ;

: _get-floor-val
  2dup floor _read-delay-pos-wrapped
;

: _get-ceil-val
  2 pick 2 pick ceil _read-delay-pos-wrapped
;

: _interpolate
  # ( real-val floor-val ceil-val -- interpolated_val )
  over - rot 1.0 % * +
;

: delay-read
  # ( delay-struct time -- delsig )
  # convert time offset to samples:
  SAMPLE_RATE *
  # add distance from write offset:
  over _get-delay-position swap -
  _get-floor-val _get-ceil-val _interpolate
  swap drop
;

: delay-write
  # ( sig delay-struct -- )
  # put it into the current write position
  tuck _set-delay-value
  # increment the write position
  t over @ % swap _set-delay-position
;

##############
# PORT (lag) #
##############
# A portamento (or lag) can be roughly done by grabbing and saving a previous sample,
# considering that a starting point for the next sample 'target', and making
# the decision: is this a rising slope or a falling slope? We have half-way
# point parameters for both. The algorithm is basically:
#   * fetch the previous sample value (call it the 'oldsig')
#   * fetch the current signal (call it the 'sig')
#   * if the previous sample is lower than the current signal, add:
#       sig oldsig - 0.5 * rise-time-in-samples /
#       and +/save it to the accumulator
#   * if the previous sample is higher than the current signal, add:
#       sig oldsig - 0.5 * fall-time-in-samples /
#       ...and +/save it to the accumulator
# Neat bonus: this 'port' ugen can be used to make envelopes!
# See the example file 'bell_of_doom.fs' for an example.

: _port-factor 1 swap 0.5 * SAMPLE_RATE * / ;
: _get-rising-factor 1 + @ ;
: _get-falling-factor 2 + @ ;

: make-port
  # ( rise-sec fall-sec -- struct )
  create swap
  0.0 , _port-factor , _port-factor ,
;

: port
  # ( sig pa -- out-sig )
  tuck @ - dup
  0 >
  if
    2dup swap _get-rising-factor *
  else
    2dup swap _get-falling-factor *
  endif
  swap drop over @ + tuck swap !
;

###########
# FILTERS #
###########

: _xt0_coef 0 + ;
: _xt1_val 1 + ;
: _xt1_coef 2 + ;
: _yt1_val 3 + ;
: _yt1_coef 4 + ;

: _reinit-filter1 5 times 0 over i + ! again drop ;

: make-filter1 create 5 allot ;

: update-filter1
  # This is where you give your filter its coefficients
  # ( flt yt1cf xt1cf xt0cf -- )
  3 pick _xt0_coef !
  2 pick _xt1_coef !
  swap _yt1_coef !
;

: filter1
  # This is actually the signal processor
  # ( sig flt reinit -- output-sig )
  if
    dup _reinit-filter1
  endif
  # ( sig flt )
  dup _xt0_coef @ 2 pick *
  # ( sig flt xt0cf*sig )
  over dup _xt1_val @ swap _xt1_coef @ *
  # ( sig flt xt0cf*sig xt1val*xt1cd  )
  3 pick 3 pick _xt1_val !
  # ( sig flt xt0cf*sig xt1val*xt1cd  )
  2 pick dup _yt1_val @ swap _yt1_coef @ *
  # ( sig flt xt0 xt1 yt1*yt1cf )
  -1 * + +
  # ( sig flt new_y )
  swap 2dup _yt1_val !
  # ( sig new_y flt )
  rot drop drop
  # ( new_y )
;

#################
# BIQUAD FILTER #
#################

: xt1_bq 0 + ;
: yt1_bq 1 + ;
: xt2_bq 2 + ;
: yt2_bq 3 + ;
: fcon_bq 4 + ;
: resonance_bq 5 + ;
: alpha_bq 6 + ;
: beta_bq 7 + ;
: gamma_bq 8 + ;
: denom_bq 9 + ;
: b0_bq 10 + ;
: b1_bq 11 + ;
: b2_bq 12 + ;
: a0_bq 13 + ;
: a1_bq 14 + ;
: a2_bq 15 + ;

: make-biquad create 16 allot ;

: calc_fcon
  # ( cutoff -- fcon )
  2PI INV_SAMPLE_RATE * *
;

: calc_alpha
  # ( res fcon -- alpha }
  1 2 pick 2 * 2 pick cos dup * *
  # ( res fcon 1 res*2*cos(fcon)*cos(fcon)
  3 pick dup *
  # ( res fcon 1 res*2*cos(fcon)*cos(fcon) res*res
  3 pick 2 *
  # ( res fcon 1 res*2*cos(fcon)*cos(fcon) res*res fcon*2
  cos * + -
  # ( res fcon 1-(res*2*cos(fcon)*cos(fcon))+(res*res*cos(fcon*2))
  -rot 2drop
  # ( alpha )
;

: calc_beta
  # ( res fcon -- beta )
  over dup
  # ( res fcon res res)
  * over 2 * sin *
  # ( res fcon res*res*sin(fcon*2) )
  2 pick 2 * 2 pick dup cos swap sin * * -
  # ( res fcon (res*res*sin(fcon*2))-(res*2*cos(fcon)*sin(fcon)) )
  -rot 2drop
;

: calc_gamma
  # ( fcon -- gamma)
  cos 1 +
;

: calc_m1
  # ( fcon beta gamma alpha -- denom )
  * rot sin rot * +
  # ( gamma*alpha+sin(fcon)*beta )
;

: calc_m2
  # ( fcon beta gamma alpha -- denom )
  * rot sin rot * -
  # ( gamma*alpha+sin(fcon)*beta )
;

: calc_denominator
  # ( fcon beta gamma alpha -- den )
  2over 2over calc_m1 dup * savepush
  calc_m2 dup * savepop + sqrt

: biquad_compute
  # ( sig struct -- sig-out )
  over savepush
  # ( sig struct )  ( sig )
  # the actual transformative equation:
  dup b0_bq @ rot *
  # ( struct b0bq*sig )  ( sig )
  swap
  # ( b0bq*sig struct )  ( sig )
  dup b1_bq @ over xt1_bq @ * rot +
  # ( struct b1bq*xt1+b0bq*sig )  ( sig )
  savepush
  # ( struct )  ( b1bq*xt1+b0bq*sig sig )
  dup b2_bq @
  # ( struct b2bq )  ( b1bq*xt1+b0bq*sig sig )
  over xt2_bq @ *
  # ( struct b2bq+xt2bq )  ( b1bq*xt1+b0bq*sig sig )
  savepush
  # ( struct )  ( b2bq+xt2bq  b1bq*xt1+b0bq*sig sig )
  dup a1_bq @ over yt1_bq @ * -1 *
  # ( struct -a1bq*yt1bq )  ( b2bq+xt2bq  b1bq*xt1+b0bq*sig sig )
  savepush
  # ( struct )  ( -a1bq*yt1bq  b2bq+xt2bq  b1bq*xt1+b0bq*sig sig )
  dup a2_bq @ over yt2_bq @ * -1 *
  # ( struct -a2bq*yt2bq )  ( -a1bq*yt1bq  b2bq+xt2bq
                             # b1bq*xt1+b0bq*sig  sig )
  savepop savepop savepop + + +
  # ( struct partial_sig )  ( sig )
  over a0_bq @ /
  # ( struct sig-out )  ( sig )
  # update state:
  over xt1_bq @ 2 pick xt2_bq !
  # ( struct sig-out )  ( sig )
  savepop 2 pick xt1_bq !
  # ( struct sig-out )  ( )
  over yt1_bq @ 2 pick yt2_bq !
  # ( struct sig-out )  ( )
  tuck swap yt1_bq !
  # ( sig-out )  ( )
;

: reinit_biquad
  # ( struct )
  0.0 over xt1_bq !
  0.0 over xt2_bq !
  0.0 over yt1_bq !
  0.0 over yt2_bq !
  drop
;

: biquad_helper
  # ( sig struct reinit res flc -- sig-out )
  over 4 pick resonance_bq !
  # ( sig struct reinit res flc )
  dup 4 pick fcon_bq !
  # ( sig struct reinit res flc )
  2dup calc_alpha 4 pick alpha_bq !
  # ( sig struct reinit res flc )
  2dup calc_beta 4 pick beta_bq !
  # ( sig struct reinit res flc )
  dup calc_gamma 4 pick gamma_bq !
  # ( sig struct reinit res flc )
  3 pick dup
  # ( sig struct reinit res flc struct struct )
  fcon_bq @ swap dup
  # ( sig struct reinit res flc fcnbq struct struct )
  beta_bq @ swap dup
  # ( sig struct reinit res flc fcnbq betabq struct struct )
  gamma_bq @ swap
  # ( sig struct reinit res flc fcnbq betabq gammabq struct )
  alpha_bq @
  # ( sig struct reinit res flc fcnbq betabq gammabq alphabq )
  calc_denominator 3 pick denom_bq !
  # ( sig struct reinit res flc )
  # put b0 into struct:
  3 pick alpha_bq @ dup * 4 pick beta_bq @ dup * + 1.5 *
  # ( sig struct reinit res flc 1.5*alphabq*alphabq+betabq*betabq )
  4 pick denom_bq @ / 4 pick b0_bq !
  # ( sig struct reinit res flc )
  # put b1 into struct:
  3 pick b0_bq @ 4 pick b1_bq !
  # ( sig struct reinit res flc )
  2drop swap
  # ( sig reinit struct )
  # put b2 into struct:
  0.0 over b2_bq !
  # put a0 into struct:
  1.0 over a0_bq !
  # put a1 into struct:
  -2.0 over resonance_bq @ *
  # ( sig reinit struct -2*resbqval )
  over fcon_bq @ cos *
  # ( sig reinit struct -2*resbqval*cos(fconbqval) )
  over a1_bq !
  # ( sig reinit struct )
  # put a2 into struct:
  dup resonance_bq @ dup *
  # ( sig reinit struct resbqval*resbqval )
  over a2_bq !
  # ( sig reinit struct )
  # reinit?
  swap if dup reinit_biquad endif
  ## ( sig struct  )
  # activate actual transformational equations:
  biquad_compute
;

: biquad
  # ( sig struct reinit res cutoff -- sig-out )
  calc_fcon biquad_helper
;
#####################
# END BIQUAD FILTER #
#####################


##########
# OUTPUT #
##########

# will send out to global L and R channels 
# ( sig pan -- )
: panmix
  2dup
  PI_DIV_2 * sin
  * lcget + lcset
  PI_DIV_2 * cos
  * rcget + rcset
;

# sending out the signal
: sendout
  BIT_DEPTH * round bytes32
;

: stereo-out
  lcget sendout
  rcget sendout
;
