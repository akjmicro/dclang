"math.dc"        import
"redis_music.dc" import
"midi.dc"        import
"linked_list.dc" import

# Adding the ability to have multiple instances running with different
# MIDI channels. Code will later subtract 1 to get 0-based indices.

var midi_channel

: populate_midi_channel
  "MIDI_CHANNEL" envget dup 0 = if drop 1 else tonum endif midi_channel !
;

populate_midi_channel

# END adding MIDI CHANNEL

var base_pitch  redis_music.get_base_pitch  base_pitch !
var edo         redis_music.get_edo                edo !

##########################################################################
# Came across a situation with the Behringer Proton where it wasn't by   #
# default set to a whole step for default pitch bend, but an octave. If  #
# you happen to be using such a synth, and you alter the default pitch   #
# bend via setting an envvar, BEND_RANGE, to the number corresponding to #
# the semitone range. For the out-of-box Proton, that would be 12.       #
##########################################################################
var bend_depth

: set_bend_depth
  "BEND_RANGE" envget
  dup 0 = if
    drop
    4096 bend_depth !
  else
    tonum 8192 swap / round bend_depth !
  endif
;

set_bend_depth

: O- 1 - ;  # subtract an octave
: O+ 1 + ;  # add an octave

64 63 / log2 const 64_63
28 27 / log2 const 28_27
21 20 / log2 const 21_20
16 15 / log2 const 16_15
10  9 / log2 const 10_9
11 10 / log2 const 11_10
 9  8 / log2 const  9_8
 7  6 / log2 const  7_6
32 27 / log2 const 32_27
 6  5 / log2 const  6_5
 5  4 / log2 const  5_4
81 64 / log2 const 81_64
 4  3 / log2 const  4_3
11  8 / log2 const 11_8
45 32 / log2 const 45_32
 3  2 / log2 const  3_2
32 21 / log2 const 32_21
 8  5 / log2 const  8_5
 5  3 / log2 const  5_3
27 16 / log2 const 27_16
 7  4 / log2 const  7_4
16  9 / log2 const 16_9
 9  5 / log2 const  9_5
11  6 / log2 const 11_6
15  8 / log2 const 15_8

#######################################################################
# Scales defined here. N.B. scales are measured in octaves (via log2) #
# The idea is that `edo_degree_*` words can dynamically use the `edo` #
# variables to multiply and round to get a degree.                    #
#######################################################################

create otonal 0 O- O- ,
              0 O- ,                              3_2 O- ,
              0    ,          5_4    ,            3_2    , 7_4 ,
              0 O+ , 9_8 O+ , 5_4 O+ , 11_8 O+ ,  3_2 O+ ,
var otonal_size
  here 1 - otonal -
otonal_size !

create pentatonic 0 O- , 9_8 O- , 4_3 O- , 3_2 O- , 16_9 O- ,
                  0    , 9_8    , 4_3    , 3_2    , 16_9    ,
                  0 O+ ,
var pentatonic_size
  here 1 - pentatonic -
pentatonic_size !

create s4679 0 O- , 3_2 O- , 7_4 O- , 0 , 9_8 ,
var s4679_size
  here 1 - s4679 -
s4679_size !

##########################################################################
# Some traditional diatonic modes, expressed as 5-limit JI. There are of #
# course different flavors, including Pythagorean and 7-limit, etc.      #
##########################################################################

create ionian   0 O-       ,                          4_3 O-    , 3_2 O-     ,
                0          ,  9_8       , 5_4       , 4_3       , 3_2        , 5_3       , 15_8       ,
                0 O+       ,  9_8 O+    , 5_4 O+    , 4_3 O+    , 3_2 O+     , 5_3 O+    , 15_8 O+    ,
                0 O+ O+    ,  9_8 O+ O+ , 5_4 O+ O+ , 4_3 O+ O+ , 3_2 O+ O+  , 5_3 O+ O+ , 15_8 O+ O+ ,
                0 O+ O+ O+ ,
var ionian_size
  here 1 - ionian -
ionian_size !

create dorian   0 O-       ,                          4_3 O-    , 3_2 O-     ,
                0          ,  9_8       , 6_5       , 4_3       , 3_2        , 5_3       , 9_5       ,
                0 O+       ,  9_8 O+    , 6_5 O+    , 4_3 O+    , 3_2 O+     , 5_3 O+    , 9_5 O+    ,
                0 O+ O+    ,  9_8 O+ O+ , 6_5 O+ O+ , 4_3 O+ O+ , 3_2 O+ O+  , 5_3 O+ O+ , 9_5 O+ O+ ,
                0 O+ O+ O+ ,
var dorian_size
  here 1 - dorian -
dorian_size !

create phrygian   0 O-       ,                            4_3 O-    , 3_2 O-     ,
                  0          ,  16_15       , 6_5       , 4_3       , 3_2        , 5_3       , 9_5       ,
                  0 O+       ,  16_15 O+    , 6_5 O+    , 4_3 O+    , 3_2 O+     , 5_3 O+    , 9_5 O+    ,
                  0 O+ O+    ,  16_15 O+ O+ , 6_5 O+ O+ , 4_3 O+ O+ , 3_2 O+ O+  , 5_3 O+ O+ , 9_5 O+ O+ ,
                  0 O+ O+ O+ ,
var phrygian_size
  here 1 - phrygian -
phrygian_size !

create lydian   0 O-       ,                          45_32 O-    , 3_2 O-     ,
                0          ,  9_8       , 5_4       , 45_32       , 3_2        , 5_3       , 15_8       ,
                0 O+       ,  9_8 O+    , 5_4 O+    , 45_32 O+    , 3_2 O+     , 5_3 O+    , 15_8 O+    ,
                0 O+ O+    ,  9_8 O+ O+ , 5_4 O+ O+ , 45_32 O+ O+ , 3_2 O+ O+  , 5_3 O+ O+ , 15_8 O+ O+ ,
                0 O+ O+ O+ ,
var lydian_size
  here 1 - lydian -
lydian_size !

create mixolydian   0 O-       ,                          4_3 O-    , 3_2 O-     ,
                    0          ,  9_8       , 5_4       , 4_3       , 3_2        , 5_3       , 16_9       ,
                    0 O+       ,  9_8 O+    , 5_4 O+    , 4_3 O+    , 3_2 O+     , 5_3 O+    , 16_9 O+    ,
                    0 O+ O+    ,  9_8 O+ O+ , 5_4 O+ O+ , 4_3 O+ O+ , 3_2 O+ O+  , 5_3 O+ O+ , 16_9 O+ O+ ,
                    0 O+ O+ O+ ,
var mixolydian_size
  here 1 - mixolydian -
mixolydian_size !

create aeolian   0 O-       ,                          4_3 O-    , 3_2 O-     ,
                 0          ,  9_8       , 6_5       , 4_3       , 3_2        , 8_5       , 9_5       ,
                 0 O+       ,  9_8 O+    , 6_5 O+    , 4_3 O+    , 3_2 O+     , 8_5 O+    , 9_5 O+    ,
                 0 O+ O+    ,  9_8 O+ O+ , 6_5 O+ O+ , 4_3 O+ O+ , 3_2 O+ O+  , 8_5 O+ O+ , 9_5 O+ O+ ,
                 0 O+ O+ O+ ,
var aeolian_size
  here 1 - aeolian -
aeolian_size !

create archytas  0 O- ,                      4_3 O- , 3_2 O- ,
                 0    , 28_27     , 7_6    , 4_3    , 3_2    , 14_9 , 7_4 ,
                 0 O+ , 28_27 O+  , 7_6 O+ , 4_3 O+ , 3_2 O+ ,
var archytas_size
  here 1 - archytas -
archytas_size !

# Serre's enharmonic
create enharmonic 4_3 O- O- ,
                    0 O-    ,
                  4_3 O-    ,
                    0       , 64_63    , 16_15    , 4_3    , 3_2 , 32_21 , 8_5 ,
                    0 O+    , 64_63 O+ , 16_15 O+ , 4_3 O+ ,
var enharmonic_size
  here 1 - enharmonic -
enharmonic_size !

create equable 0 O-    ,                     4_3 O- , 3_2 O- ,
               0       , 10_9    , 11_9    , 4_3    , 3_2    , 5_3    , 11_6    ,
               0 O+    , 10_9 O+ , 11_9 O+ , 4_3 O+ , 3_2 O+ , 5_3 O+ , 11_6 O+ ,
               0 O+ O+ ,
var equable_size
  here 1 - equable -
equable_size !

var scale
var scale_size
var cur_scl_str  "" cur_scl_str !

####################################################
# Some symbols to save memory leaks from happening #
####################################################

"otonal"     const :otonal
"pentatonic" const :pentatonic
"s4679"      const :s4679
"ionian"     const :ionian
"dorian"     const :dorian
"phrygian"   const :phrygian
"lydian"     const :lydian
"mixolydian" const :mixolydian
"aeolian"    const :aeolian
"archytas"   const :archytas
"enharmonic" const :enharmonic
"equable"    const :equable

: set_scale
  redis_music.get_scale
    dup
      cur_scl_str @
    str= if
      drop
      return
    endif
  dup :otonal     str= if :otonal     cur_scl_str !  otonal     scale !  otonal_size     scale_size ! endif
  dup :pentatonic str= if :pentatonic cur_scl_str !  pentatonic scale !  pentatonic_size scale_size ! endif
  dup :s4679      str= if :s4679      cur_scl_str !  s4679      scale !  s4679_size      scale_size ! endif
  dup :ionian     str= if :ionian     cur_scl_str !  ionian     scale !  ionian_size     scale_size ! endif
  dup :dorian     str= if :dorian     cur_scl_str !  dorian     scale !  dorian_size     scale_size ! endif
  dup :phrygian   str= if :phrygian   cur_scl_str !  phrygian   scale !  phrygian_size   scale_size ! endif
  dup :lydian     str= if :lydian     cur_scl_str !  lydian     scale !  lydian_size     scale_size ! endif
  dup :mixolydian str= if :mixolydian cur_scl_str !  mixolydian scale !  mixolydian_size scale_size ! endif
  dup :aeolian    str= if :aeolian    cur_scl_str !  aeolian    scale !  aeolian_size    scale_size ! endif
  dup :archytas   str= if :archytas   cur_scl_str !  archytas   scale !  archytas_size   scale_size ! endif
  dup :enharmonic str= if :enharmonic cur_scl_str !  enharmonic scale !  enharmonic_size scale_size ! endif
      :equable    str= if :equable    cur_scl_str !  equable    scale !  equable_size    scale_size ! endif
;

set_scale

##########################
# END SCALES DEFINITIONS #
##########################

############################
# EDO calculation routines #
############################

: edo_degree_to_midi
  # input stack (rightmost is "top":
  # ( volume, edo_degree, midi_channel )
  #
  # Take an input edo degree, calculate the octave fraction against the global
  # EDO constant, which must be declared ahead-of-time, and emit midi bytes
  # to the configured MIDI output device which will sound the correct pitch
  # Middle-C is assumed to be "0" in all EDOs, so use negative numbers to go
  # below middle-C.
  svpush                      # sequester the channel number away
  redis_music.get_edo / 12 *  # scale to 12-EDO with fractional remainder
  60.5 +                      # shift to middle-C in MIDI, also overshoot fractional
  dup floor swap              # part on purpose so we can fetch the floor closest
                              # to the proper midi number; set aside by swap
  over - 0.5 -                # grab fractional part and cancel previous 0.5 shift
  bend_depth @ *              # scale by positive half step of bend
  8192 +                      # center zero at halfway for +/-
  # stack now looks like:
  # ( volume midi_note_number midi_bend ) ( midi_channel )
  _bend_to_MSB_LSB_bytes
  # now we have
  # ( volume midi_note_number bend_MSB bend_LSB ) ( midi_channel )
  # choose what to do based on if there is volume, i.e.: if the volume
  # is 0, we don't need to worry about bemd, etc. and just send the
  # simple note info
  3 pick 0 =
  if
    2drop  # drop the bend
    svpop 0x90 +
    send_midi_reverse
  else
    # send the bend
    0 svpick 0xE0 +
    send_midi_reverse
    # send the note
    svpop 0x90 +
    send_midi_reverse
  endif
;

: edo_degree_to_hz { degree }
  2
    degree
      redis_music.get_edo
    /
  pow
  base_pitch @ *
;

##############################
# Euclidean rhythm algorithm #
##############################
var cur_euclid_count
1 cur_euclid_count !
var prev_euclid_int

: euclidean_rhythm
    redis_music.get_euclid_n
      redis_music.get_euclid_d
    /
      cur_euclid_count @
    *
    round
      prev_euclid_int @
          2dup
        -
      svpush
    drop
  prev_euclid_int !
  cur_euclid_count @ 1 + cur_euclid_count !
    svpop
      dup
      1 <
        over
        redis_music.get_euclid_n >
      or
      if
        drop
        euclidean_rhythm
      endif
;

: euclidean_test_loop
  euclidean_rhythm .
  0.5 sleep
  euclidean_test_loop
;

##################################
# End Euclidean rhythm algorithm #
##################################

"euclidean"               const :euclidean
"string"                  const :string
32 mkbuf dup svpush
"rhythm_" str+
midi_channel @ tostr str+
drop svpop                const :rhythm_string

"Rhythm string is :" print :rhythm_string print cr

make_lgen_struct _rhythm_lgen
var cur_rhythm_str   "" cur_rhythm_str !

: string_rhythm
  :rhythm_string redis_get
    dup
      cur_rhythm_str @
    str= not
  if
    dup
    strdup cur_rhythm_str !
    linit_nums _rhythm_lgen !
    0 _rhythm_lgen 1 + !
  else
    drop
  endif
  _rhythm_lgen 1 lgen
  dup 0 = if drop 1 endif
;

: rhythm_generator
  redis_music.get_rhythm_type
  dup :euclidean str= if
    drop euclidean_rhythm
  else
    dup :string str= if
      drop string_rhythm
  else
    1
  endif endif
;

###############
# END RHYTHMS #
###############

##########################
# Some algorithmic stuff #
##########################

: data_player #( number -- out_edo_degree )
  ######################################################
  # Feed it a number, go ahead. It knows how to return #
  # the current scale, indexed off that number, and    #
  # return the appropriate edo degree. What you do     #
  # with it is up to you, typically, you'd use it for  #
  # input to `edo_degree_to_hz` (for dsp work), or its #
  # compadre `edo_degree_to_midi` (for midi work).     #
  ######################################################
    set_scale
      redis_music.get_mode
    +
      scale_size @ @
    absmod
      scale @
    +
    @          # value in log2 (octaves) now on stack
      redis_music.get_transpose
        12     # transposition should be in terms of 12-edo standard
      /
    +          # value in octaves, now offset by transposition in octaves (which can be a float)
      redis_music.get_edo
    *
    round      # integer EDO value now on stack, ready for `edo_degree_to_[midi|hz]`
;

: fraction_music { expansion_struct }
  redis_music.get_base expansion_struct _set_base
  redis_music.get_div  expansion_struct _set_div
    expansion_struct gen_digit_expansion
      redis_music.get_mul
    *
  data_player
;
