var __private_ll_token_holder__

" " const :blank

: _list_init_nums_helper  # ( list ) -- ( list )
  null :blank __private_ll_token_holder__ strtok
  dup null =
  if
    drop
  else
    tonum over swap lpush
    _list_init_nums_helper
  endif
;

: _lmap_helper
  over 0 svpick _lnext <>
  if
    0 svpick 0 l@          # grab next cell data
    over exec              # execute the word
    1 svpick swap lpush    # push the result to the new list
    svpop _lnext svpush    # advance the list cell
    _lmap_helper
  else
    2drop svdrop           # get rid of most of the working data
    svpop                  # leave new list on stack
  endif
;

: _lshow_helper
  2dup _lnext <>
  if
    dup 0 l@ .
    _lnext
    _lshow_helper
  else
    2drop cr
  endif
;

##############
# Public API #
##############

: linit_nums  # ( all_nums_str ) -- ( list )
  ############################################################
  # Produce a list of nums based on a space-delimited string #
  # of numbers                                               #
  ############################################################
  depth 1 <
  if
    "linit_nums: need <all_nums_str> on the stack." print cr
    return
  endif
  lmake swap
  :blank __private_ll_token_holder__ strtok
  dup null =
  if
    drop
  else
    tonum over swap lpush
    _list_init_nums_helper
  endif
;

: lmap  # ( list word_str_for_eval ) -- ( new_list )
  # Takes an existing list and a dclang word (as a string)
  # and returns a new list where the data from the existing list
  # gets evaluated by the word. The word should take a single
  # argument.
  depth 2 <
  if
    "lmap: need <list> <word_as_string> on the stack." print cr
    return
  endif
  lmake svpush
  over svpush
  _lmap_helper             # enter the helper loop
;

: lshow  # ( list ) -- ()
  depth 1 <
  if
    "lshow: need <list> on the stack." print cr
    return
  endif
  dup
  _lshow_helper
;

: make_lgen_struct  # (name_for_struct -- struct)
  # Usage: `make_lgen_struct mynew_lgen`
  # `mynew_lgen` will now be a list generator in memory
  # The structure is 2 cells: <list_addr>, <current_node>
  create 0 , 0 ,
;

: lgen { lgen_struct infinite? }
  # Iterate over the list's items (data). The list should be given
  # as part of a 2-cell 'struct' that will also hold a current
  # node iteration that can be saved between calls.
  # If `infinite?` is non-zero, repeat indefinitely.

  # If the 'current node' slot is 0, copy the head slot to it
  lgen_struct 1 + @ 0 = if
    lgen_struct @
      lgen_struct 1 +
    !
  endif
  # Check for if we've looped around
  lgen_struct @
    lgen_struct 1 + @ _lnext
  = if
    infinite? 0 = if
      return
    else
      lgen_struct @
        lgen_struct 1 +
      !
    endif
  endif
  # Examine the current node slot, grab its data via `0 l@`
  lgen_struct 1 + @
    dup
    0 l@
    # Advance the current node to 'next'
    swap
    _lnext
      lgen_struct 1 +
    !
;
