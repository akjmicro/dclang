#######################################################################
# This is really a helper library and should NOT be imported directly #
# into your code. Instead use `"music.dc" import`                     #
#######################################################################

"clock_sleep.dc" import

# for file-based reading
"r"          const :read
"/tmp/keys/" const :tmpdir
var tmpbuf
32 mkbuf tmpbuf !

: _file_get { key }
  tmpbuf @ 0 32 memset
  :tmpdir str+ key str+ drop  # done building path string
  tmpbuf @ :read fopen
  dup -1 = if
    drop "0" return
  endif
  dup freadall drop
  # cleanup
  swap fclose
  key free
;

# grab a string, turn it into a number,
# and free up the string memory
: tonum_free dup tonum swap free ;

var remainder 1 remainder !

# some common symbols
"\n"               const :NL
# timing stuff
"start_timestamp"  const :START_TIMESTAMP
"bpm"              const :BPM
"beat_period"      const :BEAT_PERIOD
"gt" make_channel_string
                   const :GATE
# DSP example tempo stuff
"drum_tempo"       const :DRUM_TEMPO
"bass_tempo"       const :BASS_TEMPO
"lead_tempo"       const :LEAD_TEMPO
# DSP example mixing stuff
"drum_vol"         const :DRUM_VOL
"bass_vol"         const :BASS_VOL
"lead_vol"         const :LEAD_VOL
# pitch stuff
"base_pitch"       const :BASE_PITCH
"edo"              const :EDO
"scale"            const :SCALE
"md" make_channel_string
                   const :MODE
"tr" make_channel_string
                   const :TRANSPOSE
# rhythm stuff
"eun" make_channel_string
                   const :EUCLID_N
"eud" make_channel_string
                   const :EUCLID_D
"rhythm_type"      const :RHYTHM_TYPE
# used for keeping a value within a certain range:
"wr" make_channel_string
                   const :WRAP
###########################################################################
# common for things like "gen_digit_expansion" and "digit_sum" algorithms #
###########################################################################
"base"  make_channel_string
                   const :BASE
# for "gen_digit_expansion" based algorithms:
"div"   make_channel_string
                   const :DIV
# for "digit_sum" fractal algorithms as well as gen_digit_expansion:
"mul"   make_channel_string
                   const :MUL
# for chaos-based randomness:
"chaos" make_channel_string
                   const :CHAOS

##########################################
# Private word for dealing with duration #
##########################################

: _get_duration
  60 :BPM _file_get tonum_free /
;

#############################################
# Synchronization for network jamming, etc. #
#############################################

: synchronized_start
    _get_duration
      :BEAT_PERIOD _file_get tonum_free
    *
      dup
        clock
        swap
      %
    -
    0.0 -  # empirical adjustment
  sleep
;

# This one allows for various instruments to drift
: get_x_tempo { which_str }
  which_str _file_get tonum_free 60 /
;

##################
# Mixing volumes #
##################

: get_drum_vol
  :DRUM_VOL _file_get tonum_free
;

: get_bass_vol
  :BASS_VOL _file_get tonum_free
;

: get_lead_vol
  :LEAD_VOL _file_get tonum_free
;

#########################################################################
# Timing API based on absolute wall clock (UTC). This helps avoid       #
# drift... Code should start a clock for their midi channel via         #
# `set_clock_start`, and call `get_on_gate` after a note_on event and   #
# `get_off_gate` after a note_off event. All the details of timing are  #
# handled for the user under-the-hood. `get_on_gate` can typically be   #
# paired with a prior call to `rhythm_generator` which returns a length #
# value and a gate value.                                               #
#########################################################################

var next_on_time
var next_off_time

: set_clock_start
  clock next_on_time !
;

: _iterate_clock { length gate }
    next_on_time @
      dup
        length _get_duration *
      +
    next_on_time !
      length _get_duration *
        gate
      *
    +
  next_off_time !
;

: get_on_gate { length gate }
  length gate _iterate_clock
  next_off_time @ sleep_until
;

: get_off_gate
  next_on_time @ sleep_until
;

########################
# mode & transposition #
########################

: get_mode
  :MODE _file_get tonum_free round
;

: get_transpose
  :TRANSPOSE _file_get tonum_free round
;

#################
# EDO and scale #
#################

: get_base_pitch
  :BASE_PITCH _file_get
  dup 0 =
  if
    drop
    "261.625"
  endif
  tonum_free
;

# TODO: make EDOs dynamic
: get_edo
  :EDO _file_get
  dup 0 =
  if
    drop
    "31"
  endif
  tonum_free
;

: get_scale
  :SCALE _file_get "\n" "" strreplace
;

: get_rhythm_type
  :RHYTHM_TYPE _file_get "\n" "" strreplace
;

#############################################################
# Helpers for algorithmic MIDI processes...                 #
# At the moment, there are two: fraction-based sequences    #
# that use digit expansion to a certain base, and a "chaos" #
# factor concept.                                           #
#############################################################

: get_remainder remainder @ dup 0 = if drop 1 endif ;
: set_remainder remainder ! ;

: get_base
  :BASE _file_get tonum_free round
  dup 2 < if drop 2 endif
;

: get_div
  :DIV _file_get tonum_free round
  dup 0 = if drop 1 endif
;

: get_mul
  :MUL _file_get tonum_free round
  dup 1 < if drop 1 endif
;

: get_chaos
  :CHAOS _file_get tonum_free
;

: get_wrap
  :WRAP _file_get tonum_free round
;

: get_euclid_n
  :EUCLID_N _file_get tonum_free
  dup 1 < if drop 1 endif
;

: get_euclid_d
  :EUCLID_D _file_get tonum_free
  dup 1 < if drop 1 endif
;

######################################
# Generalized update from redis word #
######################################
: update_from_redis { redis_key varname cast_to_num? }
    redis_key _file_get
      cast_to_num?
    if
      tonum_free
    endif
    dup varname @ <>
  if varname ! else drop endif
;
