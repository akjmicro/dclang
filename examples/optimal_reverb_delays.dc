# Mathematically figure out optimal sample-count
# values for reverb delay lengths, based on number-theory
# like phi and prime numbers.
#
# The idea is: we'll make a 16-value array, setting a desired
# minimum and maximum, figure the ratio between them, and
# crawl through the distribution via the golden ratio (phi)
# Once established, we'll scale those values based on the
# original minimum and maximum, then snap them to their
# nearest prime-# value vai `closest-prime`.

"math.dc" import

######################################
# can be manually changed as desired #
######################################
16   const SLOTS
1362 const MIN_DELAY  # delay in samples at some SR
2205 const MAX_DELAY


var phi_array 16 allot

5 sqrt 2 / 0.5 - const PHI_M1

: populate_phi_array
  SLOTS 1 - times
    PHI_M1 i * 1 %
      phi_array i +
    !
  again
  1.0
    phi_array SLOTS 1 - +
  !
;

populate_phi_array

phi_array @ SLOTS sortnums

: show_phi_array
  SLOTS times
    phi_array i + @ .
  again
  cr
;

: scale_and_snap_phi_array { lowval highval }
  SLOTS times
    highval lowval -
      phi_array i + @
    *
      lowval
    +
    round
    closest-prime
      phi_array i +
    !
  again
;

MIN_DELAY MAX_DELAY scale_and_snap_phi_array

show_phi_array
