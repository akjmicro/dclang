"http_server.dc" import
"redis.dc" import

redis_connect

"redis_control.html" "r" fopen dup
freadall drop const SLIDER_HTML fclose

# string constants
"base"  const :base
"mul"   const :mul
"wrap"  const :wrap
"div"   const :div
"chaos" const :chaos
"mode"  const :mode
"gate"  const :gate
"<html><body>OK<br>\n</body></html>\n" const :OK
create keys_to_check :base , :mul , :wrap , :div , :chaos , :mode , :gate ,
var dummy
dummy keys_to_check - const LEN_KEYS

: _check_keys_and_set
  LEN_KEYS 0 1
  for
    get_query
      keys_to_check i + @
      dup svpush
    strfind
    if
      svpop dup h@ swap redis_set
      exitfor
    endif
    svdepth 1 >=
    if
      svdrop
    endif
  next
;

: custom_response
  get_path
  "/send_value" str=
  if
    _check_keys_and_set
    zerobuf HTTP_HTML_HEADER str+
    :OK str+
    drop
  else
    zerobuf HTTP_HTML_HEADER str+
    SLIDER_HTML str+
    drop
  endif
;

: write_response
  custom_response                                        # To customize the response,
  get_accepted_conn get_connbuf HTTP_BUFSIZE write drop  # should always be here
  get_accepted_conn close drop                           # should always be here
;

: acceptloop
  srv_queue @ tcpaccept accepted_conn !
  read_incoming    # reads in the request
  process_request  # does the basic necessities like splitting the page and query
  write_response   # send the response
  acceptloop       # infinite "wait for request" loop
;

"running acceptloop; serving on port " print HTTP_PORT . cr
acceptloop

# close down connection
srv_queue @ close drop
